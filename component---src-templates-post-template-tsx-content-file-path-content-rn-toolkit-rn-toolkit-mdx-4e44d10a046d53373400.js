"use strict";(self.webpackChunkgatsby_blog=self.webpackChunkgatsby_blog||[]).push([[828],{9264:function(e,t,n){n.r(t),n.d(t,{Head:function(){return c.Ss},default:function(){return d}});var r=n(8876),s=n(4424),a=n(8860);function o(e){const t=Object.assign({p:"p",ul:"ul",li:"li",strong:"strong",pre:"pre",code:"code",h2:"h2",a:"a",span:"span"},(0,r.MN)(),e.components);return s.createElement(s.Fragment,null,s.createElement(t.p,null,"О том как использовать стейт-менеджер для хранения состояния в приложении и как\nхранить данные между его перезапусками."),"\n",s.createElement(t.p,null,"На самом деле также как на вебе за исключением одного нюанса — в React Native\nиспользуется AsyncStorage в качестве хранилища постоянных данных (между перезапуском)."),"\n",s.createElement(t.p,null,"Сегодняшние гости:"),"\n",s.createElement(t.ul,null,"\n",s.createElement(t.li,null,s.createElement(t.strong,null,"Immer"),": иммутабельность без боли"),"\n",s.createElement(t.li,null,s.createElement(t.strong,null,"AsyncStorage"),": аналог LocalStorage на вебе"),"\n",s.createElement(t.li,null,s.createElement(t.strong,null,"Redux Toolkit"),": все часто используемые пакеты redux в одном месте"),"\n",s.createElement(t.li,null,s.createElement(t.strong,null,"TypeScript"),": типизация для удобства поиска и отладки"),"\n"),"\n",s.createElement(t.p,null,"Redux Toolkit уже использует immer, поэтому отдельно его ставить не придётся.\nВсё, что необходимо установить одной командой:"),"\n",s.createElement(t.pre,null,s.createElement(t.code,{className:"language-shell"},"$ yarn add @react-native-async-storage/async-storage \\\n@reduxjs/toolkit react-redux redux redux-persist\n")),"\n",s.createElement(t.p,null,"Структура приложения, если решите поэкспериментировать:"),"\n",s.createElement(t.pre,null,s.createElement(t.code,null,".\n├── android\n├── ios\n├── src\n│   ├── screens\n│   │   └── PostsScreen.tsx\n│   ├── services\n│   │   └── api\n│   │       ├── fetch.ts\n│   │       └── posts.ts\n│   └── store\n│       ├── blog.ts\n│       └── index.ts\n├── App.tsx\n└── index.js\n")),"\n",s.createElement(t.h2,{id:"api",style:{position:"relative"}},s.createElement(t.a,{href:"#api","aria-label":"api permalink",className:"anchor before"},s.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"API"),"\n",s.createElement(t.p,null,"React Native поддерживает такие библиотеки как ",s.createElement(t.code,null,"axios"),", но в этой заметке\nпопробуем обойтись стандартным ",s.createElement(t.code,null,"fetch"),", доступным всегда. Чтобы было удобнее\nим пользоваться, создадим для него небольшую обёртку с реализацией\nтипичных методов."),"\n",s.createElement(t.pre,null,s.createElement(t.code,{className:"language-ts"},"// services/api/fetch.ts\nasync function http<T>(path: string, config: RequestInit): Promise<T> {\n  const request = new Request(path, config)\n  const response = await fetch(request)\n\n  if (!response.ok) {\n    // для примера просто текст, при желании доработать и возвращать ответ сервера\n    throw new Error(response.statusText)\n  }\n\n  // во избежание ошибки вернуть пустой объект если нет тела\n  return response.json().catch(() => ({}))\n}\n\n// get-запрос\nexport async function get<T>(path: string, config?: RequestInit): Promise<T> {\n  const init = { method: 'get', ...config }\n  return await http<T>(path, init)\n}\n\n// post-запрос\nexport async function post<T, U>(path: string, body: T, config?: RequestInit): Promise<U> {\n  const init = { method: 'post', body: JSON.stringify(body), ...config }\n  return await http<U>(path, init)\n}\n\n// и put-запрос\nexport async function put<T, U>(path: string, body: T, config?: RequestInit): Promise<U> {\n  const init = { method: 'put', body: JSON.stringify(body), ...config }\n  return await http<U>(path, init)\n}\n")),"\n",s.createElement(t.p,null,"Теперь напишем один из запросов с использванием этой обёртки. Не вдаваясь глубоко\nв детали, без учёта типов ошибок для TS:"),"\n",s.createElement(t.pre,null,s.createElement(t.code,{className:"language-ts"},"// services/api/posts.ts\nimport * as fetch from './fetch'\n\n// структура JSON-ответа: что ожидаем получить\nexport type ResponseBodyPostById = {\n  id: number\n  title: string\n  body: string\n  userId: number\n}\n\n// передавать id, получать ответ типа ResponseBodyPostById\nexport const getPostById = async (id: number) => {\n  return await fetch\n    .get<ResponseBodyPostById>(`https://jsonplaceholder.typicode.com/posts/${id}`)\n}\n")),"\n",s.createElement(t.h2,{id:"storage",style:{position:"relative"}},s.createElement(t.a,{href:"#storage","aria-label":"storage permalink",className:"anchor before"},s.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Storage"),"\n",s.createElement(t.p,null,"Одна из возможных частей хранилища: записи блога. Функция ",s.createElement(t.code,null,"createSlice")," помогает\nне допускать бойлерплейта, который обязательно появится в коде при использовании\n«голого» redux."),"\n",s.createElement(t.pre,null,s.createElement(t.code,{className:"language-ts"},"// store/blog.ts\nimport { createAsyncThunk, createSlice, isRejected } from '@reduxjs/toolkit'\nimport { getPostById } from '../services/api/posts'\n\n// какие поля содержит тело поста\ninterface IPost {\n  id: number\n  title: string\n  body: string\n  userId: number\n}\n\n// структура хранилища для блога: список постов\ninterface IState {\n  posts: IPost[]\n  loading: Boolean\n}\n\n// тип для redux-thunk\nexport interface IThunkConfig {\n  state: IState\n}\n\n// инициализация хранилища по-умолчанию\nconst initialState: IState = {\n  posts: [],\n  loading: false,\n}\n\n// асинхронный метод thunk\n// дёргает getPostById и получает ответ\nexport const fetchPostById = createAsyncThunk(\n  'blog/post',\n  async (id: number) => getPostById(id)\n)\n\n// создать часть хранилища\nconst blogSlice = createSlice({\n  name: 'blog', // название\n  initialState, // начальное состояние\n  reducers: {}, // обычные методы\n  // асинхронные методы\n  extraReducers: builder => {\n    builder\n      // активировать статус loading при отправке запроса\n      .addCase(fetchPostById.pending, state => {\n        state.loading = true\n      })\n      // что делать при успешном разрешении промиса\n      .addCase(fetchPostById.fulfilled, (state, action) => {\n        state.posts.push(action.payload)\n        state.loading = false\n      })\n      // что делать при ошибке\n      .addMatcher(isRejected, state => {\n        state.loading = false\n      })\n      // что делать по-умолчанию\n      .addDefaultCase(state => state)\n  },\n})\n\nexport default blogSlice\n")),"\n",s.createElement(t.p,null,"Осталось настроить связку Redux + AsyncStorage."),"\n",s.createElement(a.y,null,s.createElement(t.p,null,"Для приложения на React Native следует использовать AsyncStorage.\nДля веба импортировать и использовать ",s.createElement("code",null,"storage"),":\n",s.createElement("br"),s.createElement("code",null,"import storage from 'redux-persist/lib/storage'")," ")),"\n",s.createElement(t.pre,null,s.createElement(t.code,{className:"language-ts"},"// store/index.ts\nimport AsyncStorage from '@react-native-async-storage/async-storage'\nimport { configureStore } from '@reduxjs/toolkit'\nimport { combineReducers } from 'redux'\nimport {\n  persistReducer,\n  persistStore,\n  FLUSH,\n  PAUSE,\n  PERSIST,\n  PURGE,\n  REGISTER,\n  REHYDRATE,\n} from 'redux-persist'\nimport blogSlice from './blog'\n\n// объединение всех частей хранилища\nconst rootReducer = combineReducers({ blog: blogSlice.reducer })\n\n// конфигурация для redux-persist\nconst persistConfig = {\n  key: 'App',\n  version: 1,\n  storage: AsyncStorage, // только для React Native\n  whitelist: ['blog'],   // белый список: какую часть store хранить\n  // blacklist: ['blog'],\n}\n\nconst persistedReducer = persistReducer(persistConfig, rootReducer)\n\nexport const store = configureStore({\n  reducer: persistedReducer,\n  middleware: getDefaultMiddleware => [\n    ...getDefaultMiddleware({\n      serializableCheck: {\n        ignoredActions: [FLUSH, PAUSE, PERSIST, PURGE, REGISTER, REHYDRATE],\n      },\n    }),\n  ],\n  devTools: process.env.NODE_ENV !== 'production',\n})\n\nexport const persistor = persistStore(store)\n")),"\n",s.createElement(t.p,null,"Для типизации (и удобного автокомплита) redux-хуков придётся\nлибо каждый раз указывать тип, либо ",s.createElement(t.a,{href:"https://redux.js.org/usage/usage-with-typescript#define-root-state-and-dispatch-types",target:"_blank",rel:"nofollow"},"единожды прописать типы"),"\nв кастомных функциях ",s.createElement(t.code,null,"useAppDispatch/useAppSelector")," и пользоваться ими."),"\n",s.createElement(t.p,null,"Выглядит так себе, но есть лайфхак: декларация модуля ",s.createElement(t.code,null,"react-redux"),". Стейт по-умолчанию\nдолжен наследовать наш собственный рутовый стейт."),"\n",s.createElement(t.pre,null,s.createElement(t.code,{className:"language-ts"},"// store/index.ts\nexport const persistor = persistStore(store)\n\n// в конец добавить всего пару строк: тип стейта\nexport type RootState = ReturnType<typeof store.getState>\n\n// и декларацию модуля\ndeclare module 'react-redux' {\n  interface DefaultRootState extends RootState {}\n}\n")),"\n",s.createElement(t.p,null,"В этом случае всё тоже работает как ожидается и без кастомных хуков."),"\n",s.createElement(t.h2,{id:"screen",style:{position:"relative"}},s.createElement(t.a,{href:"#screen","aria-label":"screen permalink",className:"anchor before"},s.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Screen"),"\n",s.createElement(t.p,null,"Всё готово. Получим ответ от API и выведем первый пост. Для упрощения селекторы\nпишу прямо в теле скрина, но в реальности лучше выносить их отдельно."),"\n",s.createElement(t.pre,null,s.createElement(t.code,{className:"language-tsx"},"// screens/PostsScreen.tsx\nimport React from 'react'\nimport { Text, TouchableOpacity, View } from 'react-native'\nimport { useDispatch, useSelector } from 'react-redux'\nimport { fetchPostById } from '../store/blog'\n\nconst PostsScreen = () => {\n  const dispatch = useDispatch()\n\n  // получить из хранилища необходимые данные\n  const posts = useSelector(state => state.blog.posts)\n  const isLoading = useSelector(state => state.blog.loading)\n\n  // дёрнуть fetchPostById\n  const loadPosts = () => {\n    dispatch(fetchPostById(1))\n  }\n\n  // пока промис не разрешился выводить прелоадер\n  if (isLoading) {\n    return <ActivityIndicator size=\"large\" />\n  }\n\n  return (\n    <View>\n      <TouchableOpacity onPress={loadPosts}>\n        <Text>Take a post</Text>\n      </TouchableOpacity>\n      {posts.map(({ title, id }) => (\n        <Text style={{ fontWeight: 'bold' }} key={id}>\n          {title}\n        </Text>\n      ))}\n    </View>\n  )\n}\n\nexport default PostsScreen\n")),"\n",s.createElement(t.p,null,"А в точке входа приложения (что это будет за точка и где зависит от навигации, если она используется)\nподключить сконфигурированные ранее ",s.createElement(t.code,null,"store")," (хранение в приложении) и ",s.createElement(t.code,null,"persistor")," (хранение между сессиями)."),"\n",s.createElement(t.pre,null,s.createElement(t.code,{className:"language-tsx"},"// App.tsx\nimport React from 'react'\nimport { SafeAreaView, ScrollView, StatusBar } from 'react-native'\nimport { Provider } from 'react-redux'\nimport { PersistGate } from 'redux-persist/integration/react'\nimport { store, persistor } from './src/store'\nimport PostsScreen from './src/screens/PostsScreen'\n\nconst App = () => (\n  <SafeAreaView>\n    <ScrollView contentInsetAdjustmentBehavior=\"automatic\">\n      <Provider store={store}>\n        <PersistGate persistor={persistor}>\n          <PostsScreen />\n        </PersistGate>\n      </Provider>\n    </ScrollView>\n  </SafeAreaView>\n)\n\nexport default App\n")),"\n",s.createElement(t.p,null,"Теперь части хранилища, добавленные в ",s.createElement(t.code,null,"whitelist"),", будут обрабатываться ",s.createElement(t.code,null,"redux-persist"),"\nи оставаться в приложении так долго как это будет нужно. Остальное как обычно в redux."))}var l=function(e){void 0===e&&(e={});const{wrapper:t}=Object.assign({},(0,r.MN)(),e.components);return t?s.createElement(t,e,s.createElement(o,e)):o(e)},c=n(7792),i=n(7619);function u(e){var t,n;let{data:{mdx:r},children:a,pageContext:{prev:o,next:l}}=e;const{h1:u,title:d,description:p,image:m,table_of_contents:g}=r.frontmatter;return(0,s.useEffect)((()=>{(0,i.K)()}),[]),s.createElement(s.Fragment,null,s.createElement(c._W,{h1:u,title:d,description:p,image:null===(t=r.frontmatter.image)||void 0===t?void 0:t.publicURL},s.createElement(c.MV,{post:r.frontmatter,imageData:null==m||null===(n=m.childImageSharp)||void 0===n?void 0:n.gatsbyImageData},g?s.createElement(c.G8,{headings:r.tableOfContents}):null,s.createElement("div",{className:"page__content"},a,s.createElement(c.Mf,{prev:o,next:l})),s.createElement(c.QZ,null))))}function d(e){return s.createElement(u,e,s.createElement(l,e))}},8860:function(e,t,n){n.d(t,{y:function(){return r.y}});var r=n(3836)},8876:function(e,t,n){n.d(t,{MN:function(){return a}});var r=n(4424);const s=r.createContext({});function a(e){const t=r.useContext(s);return r.useMemo((()=>"function"==typeof e?e(t):{...t,...e}),[t,e])}}}]);