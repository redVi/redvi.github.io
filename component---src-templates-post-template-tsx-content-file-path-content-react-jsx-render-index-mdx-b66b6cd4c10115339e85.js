"use strict";(self.webpackChunkgatsby_blog=self.webpackChunkgatsby_blog||[]).push([[9660],{6238:function(e,n,t){t.r(n),t.d(n,{Head:function(){return c.Ss},default:function(){return u}});var l=t(8876),a=t(4424);function r(e){const n=Object.assign({p:"p",code:"code",pre:"pre",strong:"strong"},(0,l.MN)(),e.components);return a.createElement(a.Fragment,null,a.createElement(n.p,null,"В React есть несколько способов вывести список элементов. Наиболее популярный знаком, пожалуй, всем: использовать ",a.createElement(n.code,null,"map"),"."),"\n",a.createElement(n.pre,null,a.createElement(n.code,{className:"language-js"},"import React from 'react';\nimport moment from 'moment';\n\nconst week = [0, 1, 2, 3, 4, 5, 6];\n\nconst renderWeekDays = locale =>\n  week.map((day, i) => {\n    const weekDay = moment().locale(locale).weekday(day).format('dd');\n\n    return (\n      <li\n        key={`weekday-${weekDay}`}\n        style={[styles.weekDay, (i === 5 || i === 6) && styles.weekDayWeekend]}\n      >\n        {weekDay.toUpperCase()}\n      </li>\n    );\n  })\n;\n\nconst CalendarStrip = ({ locale }) => <ul>{renderWeekDays(locale)}</ul>;\n\nexport { CalendarStrip };\n")),"\n",a.createElement(n.p,null,"Если принять во внимание, что при рендеринге вызывается функция, понимаем: можно изменять её как угодно,\nлишь бы она возвращала валидные JSX-элементы. Вот как выглядит обычный ",a.createElement(n.code,null,"for")," вместо ",a.createElement(n.code,null,"map"),":"),"\n",a.createElement(n.pre,null,a.createElement(n.code,{className:"language-js"},"const renderWeekDays = locale => {\n  const week = [];\n\n  for (let i = 0; i <= 6; i += 1) {\n    const weekDay = moment().locale(locale).weekday(i).format('dd');\n\n    week.push(\n      <li\n        key={`weekday-${weekDay}`}\n        style={[styles.weekDay, (i === 5 || i === 6) && styles.weekDayWeekend]}\n      >\n        {weekDay.toUpperCase()}\n      </li>,\n    );\n  }\n\n  return week;\n};\n")),"\n",a.createElement(n.p,null,a.createElement(n.strong,null,"Условный рендеринг")," тоже может быть разным. Когда надо показывать в зависимости от состояния то один, то другой элемент,\nцелесообразно взять тернарный оператор."),"\n",a.createElement(n.pre,null,a.createElement(n.code,{className:"language-js"},"const dynamicComponent = isCorrect ? <ComponentOne /> : <ComponentTwo />;\n")),"\n",a.createElement(n.p,null,"В противном случае более читаемым код будет с оператором ",a.createElement(n.code,null,"&&"),". Это доказывает пример со стилизацией\nкомпонента в зависимости от переданных ему ",a.createElement(n.code,null,"props"),"."),"\n",a.createElement(n.pre,null,a.createElement(n.code,{className:"language-js"},"import React from 'react';\nimport { StyleSheet, TouchableOpacity } from 'react-native';\n\nconst styles = StyleSheet.create({\n  // какие-нибудь стили\n  wrapper: {...},\n  round: {...},\n  shadow: {...},\n});\n\nconst Button = ({\n  color,\n  round,\n  shadowed,\n  children,\n  onPress\n}) => (\n  <TouchableOpacity\n    style={[\n      styles.wrapper,\n      { color },\n      !!round && styles.round,\n      !!shadowed && styles.shadow,\n    ]}\n    onPress={onPress}\n  >\n    {children}\n  </TouchableOpacity>\n);\n\nexport { Button };\n\n// в дальнейшем используется как:\n// <Button round color=\"#D3474B\">\n//   <Text>Hello</Text>\n// </Button>\n")),"\n",a.createElement(n.p,null,"Да, здесь есть страшный и нечитаемый для многих оператор двойного отрицания ",a.createElement(n.code,null,"!!"),".\nИсключительно для примера, чтобы показать его полезность в некоторых случаях и вообще напомнить о его существовании.\n",a.createElement(n.code,null,"!!")," принудительно приводит то, к чему его применили, к логическому типу — вот его польза.\nПо сути это тоже самое, что ",a.createElement(n.code,null,"Boolean(value)"),", только короче. Страшен и нечитаем он лишь по незнанию.\nПрименять или нет — вопрос стайлгайда конкретной компании, но в чужом коде встретиться такое может."))}var o=function(e){void 0===e&&(e={});const{wrapper:n}=Object.assign({},(0,l.MN)(),e.components);return n?a.createElement(n,e,a.createElement(r,e)):r(e)},c=t(7792),s=t(7619);function m(e){var n,t;let{data:{mdx:l},children:r,pageContext:{prev:o,next:m}}=e;const{h1:u,title:d,description:i,image:p,table_of_contents:y}=l.frontmatter;return(0,a.useEffect)((()=>{(0,s.K)()}),[]),a.createElement(a.Fragment,null,a.createElement(c._W,{h1:u,title:d,description:i,image:null===(n=l.frontmatter.image)||void 0===n?void 0:n.publicURL},a.createElement(c.MV,{post:l.frontmatter,imageData:null==p||null===(t=p.childImageSharp)||void 0===t?void 0:t.gatsbyImageData},y?a.createElement(c.G8,{headings:l.tableOfContents}):null,a.createElement("div",{className:"page__content"},r,a.createElement(c.Mf,{prev:o,next:m})),a.createElement(c.QZ,null))))}function u(e){return a.createElement(m,e,a.createElement(o,e))}},8876:function(e,n,t){t.d(n,{MN:function(){return r}});var l=t(4424);const a=l.createContext({});function r(e){const n=l.useContext(a);return l.useMemo((()=>"function"==typeof e?e(n):{...n,...e}),[n,e])}}}]);