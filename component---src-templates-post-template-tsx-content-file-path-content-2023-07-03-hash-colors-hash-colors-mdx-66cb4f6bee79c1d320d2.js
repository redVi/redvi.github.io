"use strict";(self.webpackChunkgatsby_blog=self.webpackChunkgatsby_blog||[]).push([[2312],{6320:function(e,n,t){t.r(n),t.d(n,{Head:function(){return c.Ss},default:function(){return u}});var a=t(8876),r=t(4424),s=t(3616);function l(e){const n=Object.assign({p:"p",code:"code",pre:"pre"},(0,a.MN)(),e.components);return r.createElement(r.Fragment,null,r.createElement(n.p,null,"Задача: если не задано изображение, выводить первую букву имени и цвет для аватара. Примерно как\nв telegram или google. Палитра цветов задана. Чем меньше в ней цветов, тем больше их совпадений.\nКак вариант, можно генерировать цвета в ",r.createElement(n.code,null,"hsl"),", управляя насыщенностью - то же самое, только тонко\nпалитрой управлять не получится, зато и коллизий меньше."),"\n",r.createElement(n.p,null,"Цвет не должен меняться рандомно, поэтому потребуется механизм «запоминания». Для этого будем получать простенький хэш из имени пользователя. А уже из него добывать цвет."),"\n",r.createElement(s.k,{headings:["palette.ts","getColorFromPalette.ts","Avatar.tsx"]},r.createElement(s.s,null,r.createElement(n.pre,null,r.createElement(n.code,{className:"language-ts"},"// Палитра цветов\nexport const palette = [\n  '#F79898',\n  '#92D8FF',\n  '#AFEE88',\n  '#FCDA5D',\n  '#8482FF',\n  '#FF8946',\n  '#B490FF',\n  '#F6D86D',\n  '#B8EB29',\n  '#FF4B6C',\n  '#80BDFF',\n];\n"))),r.createElement(s.s,null,r.createElement(n.pre,null,r.createElement(n.code,{className:"language-ts"},"// Получаем значение из имени пользователя\nconst getHashOfString = (str: string): number => {\n  let hash = 0;\n  for (let i = 0; i < str.length; i += 1) {\n    hash = str.charCodeAt(i) + ((hash << 5) - hash);\n  }\n  hash = Math.abs(hash);\n  return hash;\n};\n\n// Приводим его к нужному диапазону\nconst normalizeHash = (hash: number, min: number, max: number): number =>\n  Math.floor((hash % (max - min)) + min);\n\n// Вынимаем из палитры один из цветов\nexport const getColorFromPalette = (name: string, palette: string[]) =>\n  palette[normalizeHash(getHashOfString(name), 0, palette.length - 1)];\n"))),r.createElement(s.s,null,r.createElement(n.pre,null,r.createElement(n.code,{className:"language-tsx"},"import React, { memo } from 'react';\nimport { Image, Text, View, StyleSheet } from 'react-native';\nimport { getColorFromPalette } from './getColorFromPalette';\nimport { palette } from './palette';\n\ninterface IAvatar {\n  name: string;\n  sizes?: {\n    width: number;\n    height: number;\n  };\n  radius?: number;\n  source?: string;\n  extraStyles?: object;\n}\n\nconst styles = StyleSheet.create({\n  image: {\n    resizeMode: 'cover',\n  },\n  avatar: {\n    backgroundColor: '#FD6B6F',\n    alignItems: 'center',\n    justifyContent: 'center',\n  },\n  text: {\n    color: 'white',\n    fontWeight: 'bold',\n  },\n});\n\n/* Принимает в качестве аргументов:\n  source - адрес изображения\n  sizes  - размеры аватара\n  radius - радиус углов\n  name   - имя пользователя\n  extraStyles - возможность внешней стилизации\n*/\nconst Avatar: React.FC<IAvatar> = ({\n  source = '',\n  sizes = { width: scale(30), height: scale(30) },\n  radius = 100,\n  name = '',\n  extraStyles = {},\n}) => {\n  const userName = name ? name[0]?.toUpperCase() : 'A';\n  // размер шрифта зависит от размера аватара\n  const textSize = sizes && sizes.height ? sizes.height / 1.5 : 18;\n\n  return source ? (\n    <Image\n      source={{ uri: source }}\n      style={[styles.image, sizes, { borderRadius: radius }, extraStyles]}\n    />\n  ) : (\n    <View\n      style={[\n        styles.avatar,\n        sizes,\n        {\n          borderRadius: radius,\n          backgroundColor: getColorFromPalette(name, palette) || '#FD6B6F',\n        },\n        extraStyles,\n      ]}>\n      <Text style={[styles.text, { fontSize: textSize }]}>\n        {userName}\n      </Text>\n    </View>\n  );\n};\n\nAvatar.displayName = 'Avatar';\n\nexport default memo(Avatar);\n")))),"\n",r.createElement(n.p,null,"Код компонента написан для React Native, но изменить его несложно."))}var o=function(e){void 0===e&&(e={});const{wrapper:n}=Object.assign({},(0,a.MN)(),e.components);return n?r.createElement(n,e,r.createElement(l,e)):l(e)},c=t(7792),i=t(7619);function m(e){var n,t;let{data:{mdx:a},children:s,pageContext:{prev:l,next:o}}=e;const{h1:m,title:u,description:g,image:h,table_of_contents:p}=a.frontmatter;return(0,r.useEffect)((()=>{(0,i.K)()}),[]),r.createElement(r.Fragment,null,r.createElement(c._W,{h1:m,title:u,description:g,image:null===(n=a.frontmatter.image)||void 0===n?void 0:n.publicURL},r.createElement(c.MV,{post:a.frontmatter,imageData:null==h||null===(t=h.childImageSharp)||void 0===t?void 0:t.gatsbyImageData},p?r.createElement(c.G8,{headings:a.tableOfContents}):null,r.createElement("div",{className:"page__content"},s,r.createElement(c.Mf,{prev:l,next:o})),r.createElement(c.QZ,null))))}function u(e){return r.createElement(m,e,r.createElement(o,e))}},8876:function(e,n,t){t.d(n,{MN:function(){return s}});var a=t(4424);const r=a.createContext({});function s(e){const n=a.useContext(r);return a.useMemo((()=>"function"==typeof e?e(n):{...n,...e}),[n,e])}}}]);